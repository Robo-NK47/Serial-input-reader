import serial as ser
import re, time, pickle
import matplotlib.pyplot as plt

def recording_dictionary_maker(sensonrnum):
    # Acquire the number of sensors and sets a dictionary, each key is a sensor.
    # The data is a nested list [(t1:v1),(t2:v2),...]
    keys = []
    for i in range(0,sensonrnum):
        name = 'Sensor' + str(i+1)
        keys.append(name)
    measdict = dict.fromkeys(keys, [])
    return(measdict)

def data_aq(ard1, userpref, start, datadic):
    # Reads the raw data from a serial port and inserts it
    # to a nested list
    recordedData = []
    while (time.time() - start <= userpref[0]):
        if (ard1.inWaiting() > 0):
            currentsample = []
            now = time.asctime()
            currentsample.append(now[11:19])
            currentsample.append(ard1.readline())
            recordedData.append(currentsample)
            # time.sleep(userpref[0]) - This line was meant to handle the sampling rate issue
            # Not working properly
    print("The recording operation took", int(time.time() - start), "second(s)\n")
    return recordedData

def clean_data(rawData, datadic, voltage):
    # Takes the raw data and organises it into a
    # pre-made dictionary
    to_clean=[]
    # This loop takes the raw data from the user and turns
    # it from 'byte' type into string ot int.
    # After, it will insert a tuple which contains the
    # time which the sample was taken in, the measured data
    # and a sample number.
    for i in range(0,len(rawData)):
        current_time = rawData[i][0]
        current_data = str(rawData[i][1])
        if current_data.find('aaaa') != (-1):
            current_data = 'aaaa'
        else:
            try:
                current_data = float(re.search(r'\d+', current_data).group())
            except:
                current_data = current_data
        data_cell = [current_time,current_data,i]
        to_clean.append(data_cell)
    # This loop constructs a temporary nested list.
    # The cleaned data will be chopped into it.
    temp = []
    for i in range(0, len(datadic)):
        temp.append([])
    # This loop takes us to the first header cell
    k = 0
    con = False
    while not con:
        if to_clean[0][1] != 'aaaa':
            to_clean.pop(0)
        if to_clean[0][1] == 'aaaa':
            con = True
        k = k+1
    print(str(k), "Data packet(s) were lost due to data alignment issues\n")
    # This loop chops the cleaned data into the cells of
    # the temporary nested list.
    while len(to_clean)>0:
        if to_clean[0][1] == 'aaaa':
            to_clean.pop(0)
        for i in range(0,len(datadic)):
            if len(to_clean) > 0:
                temp[i].append(to_clean.pop(0))
    # This loop inserts the cleaned data sets into a pre-made
    # dictionary.
    for i in range(0,len(temp)):
        for j in range(0,len(temp[i])):
            try:
                temp[i][j][1] = temp[i][j][1]*voltage/1023
            except:
                temp[i][j][1] = temp[i][j][1]
    for i in range(0, len(datadic)):
        current_sensor = 'Sensor' + str(i + 1)
        datadic[current_sensor] = temp[i]
    return datadic

def countdown():
    # Gives the user a few seconds to prepare for a
    # data recording session
    time.sleep(2)
    print(" ")
    print("The recording will begin in:")
    for i in range(0, 3):
        print(3 - i, "seconds")
        time.sleep(1)
    print(" ")

def user_pref_input():
    # Makes a list containing the users preferences
    con = False
    while not con:
        userpref = []
        try:
            userpref.append(float(input("Please enter the overall time of sample recording: ")))
            userpref.append(int(input('What is the number of sensors? ')))
            userpref.append(float(input("What is the maximal voltage? ")))
            #userpref.append(float(input("Please enter the time between sample recording: ")))
            con = True
        except:
            print("Invalid input")
    return userpref

def simple_graph_maker(data, userpref):
    # Makes a simple X-Y graph for a given data set
    plt.style.use('fivethirtyeight')
    for i in range(0, len(data)):
        current_sensor = 'Sensor' + str(i + 1)
        current_data = data[current_sensor]
        sample = []
        voltage = []
        for j in range(0,len(current_data)):
            if type(current_data[j][1])==float and 0<=current_data[j][1]<=1023:
                sample.append(j)
                voltage.append(current_data[j][1])
        print(len(current_data) - len(voltage), "Data packets were lost from " + current_sensor+"\n")
        plt.plot(sample, voltage, label=current_sensor)
    plt.xlabel("Sample [#]")
    plt.ylabel("Voltage [V]")
    plt.title("Voltage as a function of Time \n["+str(int(userpref[0]))+" seconds of recording]")
    plt.legend()
    plt.show()

def histogram_maker(data):
    # Makes a histogram graph for a given data set
    plt.style.use('fivethirtyeight')
    con = False
    while not con:
        try:
            resolution = int(input("To how many bins would you like your histogram to be divided to? "))
            print(" ")
            if resolution!= 0:
                con = True
        except:
            print("Invalid input, please insert a natural number larger than 0")
    a = 0.9/len(data)
    for i in range(0, len(data)):
        current_sensor = 'Sensor' + str(i + 1)
        data_set = data[current_sensor]
        voltage = []
        for j in range(0,len(data_set)):
            if type(data_set[j][1]) == float and 0 <= data_set[j][1] <= 1023:
                voltage.append(data_set[j][1])
        b = a*(1-i/len(data))
        bins = []
        k=0
        for j in range(0,resolution+1):
            bins.append(k)
            k = k+float(5 / resolution)
        plt.hist(voltage, bins=bins, edgecolor='black', label=current_sensor, histtype='bar', rwidth=a)
    bin_header = []
    add = (5 / resolution)
    adder = float(add)
    for j in range(0, resolution):
        first = str(j * adder)
        to_first = first[0:3]
        second = str((j + 1) * adder)
        to_second = second[0:3]
        current_bin = to_first + '-' + to_second
        bin_header.append(current_bin)
    plt.xlabel(bin_header)
    plt.ylabel("# of samples per bin")
    plt.title("Voltage histogram")
    plt.legend()
    plt.show()

def save_file(data):
    # Saves a file for given data
    t = str(time.asctime())
    file_name = str(re.sub('[:!@#$]', '_', t))+'.pkl'
    print("The file name is: "+file_name+"\n")
    with open(file_name, "wb") as f:
        pickle.dump(data, f)
        del data

def open_file():
    # Open saved files
    con = False
    while not con:
        try:
            file_name = str(input("Please enter the data file name: "))
            con = True
        except:
            print("Invalid input")
    file_name = file_name
    my_file = pickle.load(file=open(file_name, "rb"))
    return my_file

def user_options(datadict):
    # Asks the user what would he like to do
    con = False
    while not con:
        try:
            what_to_do = str(input("Would you like to do? Enter 's' to save a file, 'o' to open a saved file or 'x' to exit: "))
            print(" ")
            con = True
        except:
            print("Invalid input")
    if what_to_do=='s':
        return (save_file(datadict))
    if what_to_do == 'o':
        print(open_file())
    if what_to_do == 'x':
        return 0

def graph_chooser(data, userpref):
    what_to_do = 'o'
    while what_to_do != 'x':
        con = False
        while not con:
            try:
                what_to_do = str(input("Enter 'xy' to create X-Y Graphs, 'h' to create histograms or 'x' to proceed: "))
                print(" ")
                con = True
            except:
                print("Invalid input")
        if what_to_do == 'xy':
            simple_graph_maker(data, userpref)
        if what_to_do == 'h':
            histogram_maker(data)
